# ☕ JAVA

### 자바 17에서의 추가적인 기능은?

* Records
* Stream.toList()
* Instanceof 변수 생성



## 🦾 컴파일 & 메모리

### 자바는 컴파일언어일까 인터프리터 언어일까?

자바는 컴파일과 인터프리터 두 방식을 모두 사용하고 있습니다.

### 자바는 왜 컴파일을 할까?

* 자바는 고수준 언어에서 작성 된 Java파일을 컴파일하여 바이트 코드인 class파일로 컴파일하는 작업을 하게 됩니다.
* 이는 한번 작성한 코드를 어느 운영체제에서든 실행 가능하도록 한 자바의 목적에 의해서 JVM만 있다면 어디서든 동작이 가능하도록 JVM이 이해할 수 있는 바이트코드로 변환하기 위해 이러한 작업을 거치게 됩니다.



### 자바의 컴파일 과정은?

<figure><img src="../.gitbook/assets/image (118).png" alt=""><figcaption><p><a href="https://velog.io/@mooh2jj/JIT-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EB%9E%80">https://velog.io/@mooh2jj/JIT-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EB%9E%80</a> 참조</p></figcaption></figure>

* **javac**: 자바 컴파일러가 .Java 파일을 바이트코드인 .class파일로 컴파일합니다.
* **클래스 로더**: 컴파일된 바이트코드를 JVM으로 가져옵니다.
* **JVM**: 컴퓨터가 이해할 수 있는 기계어로 변환합니다.
  * 인터프리터: 바이트코드를 실시간으로 기계어로 변환하며 실행합니다.
  * JIT(Just-in Time) 컴파일러: 자주 사용되는 코드를 변환하여 캐싱하여 두고 재사용합니다.



### JRE와 JDK의 차이점은?

* **JRE**는 미리 작성된 자바코드를 실행시키기 위해서만 사용되고,
* **JDK**는 JRE 기능을 포함하며 개발자가 자바를 개발하는데 사용할 수 있도록 컴파일러, jar 등을 추가로 제공합니다.



### byte, short, int, long, double, float, char, string boolean 메모리 할당 크기는?

* byte: 1 byte
* short: 2 byte
* int: 4 byte
* long: 8 byte
* float: 4 byte
* double: 8 byte
* char: 2 byte
* string:&#x20;
* boolean: 1 byte

### 자바의 메모리구조

#### Method Area

* JVM의 클래스 로더에 의해 로드 된 클래스와 Method 정보, 클래스 변수 등을 관리합니다.

#### Stack:&#x20;

* 각 메서드 호출에 관련된 데이터를 저장하는 영역입니다.
* 각 스레드 별로 별도의 스택 영역이 생성됩니다.

#### Heap

* 힙은 new 키워드로 생성되는 모든 객체에 대해 저장하고 관리하는 영역입니다.
* 이 영역은 주로 동적으로 크기가 할당되고 관리하게 됩니다.
* GC의 관리 대상입니다.

#### Native Method Stack

* 자바가 아닌 다른 언어환경에서 실행되는 코드에 대한 메모리를 관리합니다.



### Runtime Constant Pool과 Constant Pool 차이는?

### Constant Pool과 String Constant Pool 차이는?



## 🔠 변수

### 기본자료형이란?



### 참조자료형이란?



### Integer 값 비교시 ==를 사용하면 안되는 이유

* 우선 int는 기본 자료형이고, Integer는 참조 자료형이며 래퍼 클래스입니다.&#x20;
* 따라서 기본 자료형끼리만 비교할 경우 문제가 되지 않지만, 래퍼 클래스끼리 비교하게 될 경우 equals() 메서드를 통해 같은 참조를 비교하는 것이 아닌 실제 값을 비교해주어야 합니다.
* 다만, -128 \~ 127의 범위에 값에 대해서는 Integer 클래스 내부에 캐싱된 값을 가지고 있으므로 == 로 비교하여도 동일한 주소를 참조해 결과가 동일하게 나올 수 있습니다.

### 맴버 변수란?

#### 클래스 변수

* 해당 클래스에 모든 인스턴스에서 공유 되어 사용 가능한 값입니다.
* 객체가 아닌 클래스의 상태를 나타내는 값입니다.
* 전역변수의 성질을 가지고 있습니다.

```java
public class Zoo {
    static int animalCount = 0; // 클래스 변수
}

class Test {
    void testMethod() {
        Zoo.animalCount++;
    }
}
```

#### 인스턴스 변수

* 인스턴스(객체)의 상태를 나타낼 수 있는 값입니다.
* 객체를 생성할 때마다 새로운 인스턴스 변수가 메모리에 할당됩니다.
* 때문에, 객체(인스턴스)를 생성 해야지만 사용할 수 있습니다.

```java
public class Zoo {
    int animalCount = 0; // 인스턴스 변수
}

class Test {
    void testMethod() {
        Zoo animalCount = new Zoo();
        animalCount++;
    }
}
```



### 지역 변수란?

* 메소드 내에 선언되며 메소드 내에서만 사용 가능한 변수 입니다.
* 보통 메소드가 종료되면 함께 소멸합니다.

```java
public class Zoo {
    void testMethod() {
        int animalCount = 0; // 지역 변수
    }
}
```



### 전역 변수 VS 맴버 변수

* 가끔자바에서는 흔히 이 두 가지 용어를 혼용하여 동의어처럼 사용하기도 합니다.
* 하지만 **맴버 변수**의 경우 두 가지 변수를 포함하는 개념인데,
  * 먼저, 클래스 변수는 클래스 전체 범위(모든 인스턴스)에서 접근이 가능하여 동일한 개념이지만,
  * 인스턴스 변수는 각 인스턴스 별로 다른 변수 값을 가지게 되므로 다르다고 볼 수 있습니다.
* 때문에 결과적으로는 실제 두 개념이 다르다는 것을 **꼭** 인지해야 합니다.

#### 📚 참고자료

* [Integer "==" 비교에 대한 글](https://dzone.com/articles/java-integer-cache-why-integervalueof127-integerva)



### 래퍼 클래스 캐싱 범위

* **Integer, Long, Short** : -128 \~ 127 범위까지 만
* **Byte**: 전체 범위 (-128 \~ 127)
* **Character**: 0 \~ 127 범위까지 만

단, JVM의 -XX:AutoBoxCacheMax 옵션으로 캐싱 값 범위를 변경할 수는 있지만 Integer만 변경할 수 있다.



### BigDecimal을 왜 사용할까?

* 자바에선 기본적으로 실수를 처리하는데 float와 double의 기본 자료형을 제공하고 있습니다.
* 하지만 이 자료형 모두 컴퓨터가 숫자 연산을 더 효율적으로 하기 위해 부동소수점을 사용한 2진수 형태로 변환하여 저장을 하게 됩니다.
* 이 과정에서 소수 부분이 2진수로 변환할 때 무한 소수가 발생하게 되는데 이는 각 메모리의 한계로 인해 나머지가 반올림 등으로 버려지기 때문에 정확한 값을 얻을 수가 없습니다.
* 때문에 금융권과 같이 중요한 계산이 이루어져야 할 경우에는 BigDecimal를 사용하여 10진수 방식으로 계산을 하여 정확한 소수점 자리까지도 계산이 가능하도록 해야 합니다.



#### 📚 참고자료

* [부동 소수점의 이해 (1부)](https://devocean.sk.com/blog/techBoardDetail.do?ID=165270\&boardType=techBlog)
* [부동 소수점의 이해 (2부)](https://devocean.sk.com/blog/techBoardDetail.do?page=\&boardType=undefined\&query=\&ID=165276\&searchData=\&subIndex=)
* [BigInteger와 BigDecimal](https://hudi.blog/java-biginteger-bigdecimal/)

## 🧩 객체 지향

해결해야 할 문제 상황에 대하여 데이터와 이 데이터를 사용하는 기능을 하나의 객체로 묶어 책임을 분리하고 이러한 객체들의 협력적인 관계를 통해 문제를 해결하는 프로그래밍 패러다임입니다.

### 왜 데이터와 기능이 하나의 객체에 존재해야 할까?

이렇게 하는 이유는 크게 **응집성**과 **캡슐화**를 설명 드릴 수 있을 것 같습니다.

* **응집성:** 데이터와 해당 데이터를 사용하는 기능이 함께 객채에 존재하게되면 응집성이 높다고 볼 수 있습니다. 이렇게 응집성이 높아지면 코드를 이해하기가 쉽고 유지보수성이 높아지게 됩니다. 또한 이렇게 잘 응집된 객체는 책임이 잘 분리되어 재사용성이 높아지게 됩니다.
* **캡슐화:** 이렇게 하나의 객체 안에서 데이터와 역할이 함께 존재하게 된다면, 외부에서는 해당 객체에 직접적인 기능을 정의하지 않고 인터페이스에만 의존할 수있게 되어 데이터의 일관성을 보장할 수 있게되고, 또한 수정 사항이 발생 시 외부에선 인터페이스에만 의존하기 떄문에 수정사항이 전파되지 않는 장점을 얻을 수 있습니다.



### 객체 지향 프로그래밍의 장점은?

* 다형성과 캡슐화를 통해서 내부의 수정사항이 발생하더라도 외부에선 인터페이스에만 의존하고 있기 때문에 수정이 전파되지 않아 유지보수에 용이하고,
* 각 객체별로 책임 잘 분리가 되어있다면 코드의 재사용성이 높아지게 됩니다.
* 이는 또한 단위 테스트를 작성할 때에도 각 기능에 대해 독립적으로 테스트 할 수 있어 버그를 잡아내는데 더욱 유리합니다.



### 객체 지향 프로그래밍의 단점은?

* 절차 지향 프로그래밍에 비해 속도가 조금 느릴 수 있습니다. 이는 객체지향은 모든 것을 객체로 보기 때문에 이를 생성하고 소멸시키며 포인터 크기에 대한 메모리와 연산에 대한 비용이 들게 됩니다.
* 많은 추상화를 진행하다보면&#x20;
* 설계에 대한 비용과 이를 이해하기 위한 학습 곡선이 높을 수 있습니다.



### 추상화란?

* 추상화란 해결해야 할 문제 상황에 대하여 중요한 로직이나 특성들을 드러내고 불필요한 구체적인 세부사항들을 감추며 시스템의 복잡성을 낮추고 중요한 로직에 집중할 수 있는 방법입니다.



### 다형성이란?

* 다형성이란 같은 인터페이스나 부모클래스를 여러 타입의 다른 객체들을 다룰 수 있는 기능을 말합니다.
* 이는 오버라이딩과 같은 기능을 통하여 새로운 객체가 추가되더라도 기존의 코드를 수정하지 않고 유연하게 확장할 수 있습니다.



### 상속이란?

* 기존에 생성된 클래스를 자식 클래스가 이어받아 부모 클래스에 있는 맴버변수나 메서드 등을 그래도 사용할 수도 있고 상황에 따라 오버라이드 하여 확장하여 사용할 수도 있습니다.
* 물론 접근 제어자에 따라서 사용할 수 있는 범위는 제한될 수도 있습니다.



### 캡슐화란?





### 추상클래스와 인터페이스 차이

* 우선 첫번째로 상속과 구현을 한다는 차이점이 있습니다.
  * 자바에서는 상속은 하나의 클래스만 할 수 있으나 인터페이스는 여러개를 구현할 수도 있습니다.
* 추상 클래스는 맴버 변수를 가질 수 있으나, 인터페이스는 상수만 가질 수 있습니다.
* 접근 제어자에서도 차이가 있습니다. 추상 클래스는 모든 접근 제어자를 사용할 수 있는 반면, 인터페이스는 public을 default로 사용하고 주로 default나 static 메서드 내에서 재사용하기 위해 private를 사용할 수도 있습니다.
* 마지막으로는 인터페이스는 생성자를 가질 수 없는 반면 추상 클래스는 생성자를 가질 수 있어 이를 통해 자식 클래스에서는 부모 클래스의 생성자를 통해 초기화 할 수도 있습니다.



## JVM

자바를 실행하기 위한 가상 머신으로 컴파일 된 바이트 코드를 읽어 어느 운영체제에서든 동작 할 수 있도록 역할을 하고 있습니다.



### 🗑️ 가비지 컬렉터 (GC)

### Minor GC란?

Young 영역의 가비지를 수집하기 위한 GC 방법으로 주로 Eden영역과 Survivor 영역에서 이루어집니다.



### Major GC란?

주로 Old 영역의 가비지를 수집하기 위한 GC 방법으로 Minor GC에 비해 STW가 더 오랜 시간 발생하게 됩니다.



### Young 영역과 Old 영역 중 어느 곳이 더 클까?

* 이는 Old Generation이 더 큽니다.
* 이유는 Young 영역에 할당되는 변수들은 기본적으로 일회성으로 동작하는 경우가 많고 생명주기가 대체로 짧기 때문에 필요한 메모리 양이 적고 금방 사라지는 데이터라고 볼 수 있습니다.
* 그에 반에 오래 살아남는 데이터는 Old 영역으로 보내지기 때문에 비교적 크기가 큰 변수들이 존재할 가능성이 높아 이렇게 설계가 되었습니다.



### Garbage 판단 기준

* 힙 내에서 다른 객체에 의한 참조
* Java 스택에 의한 참조 (Java 메서드 실행 시 사용하는 지역변수나 파라미터 변수)
* JNI에 의한 참조 (Java Native Interface에서 생성한 객체)
* Method Area의 static 변수에 의한 참조



### 각 GC 별 차이

#### Parallel GC: 다중 쓰레드가 병렬적으로 GC를 작업합니다. 단 Young과old 영역 등 각 영역에 전체를 GC하기에 성능 상 좋지 않습니다.

#### G1 GC: 기존의 Young과 Old 영역을 사용하는 것 대신, 마치 체스판과 같이 region 영역으로 칸을 미리 나누고 유동적으로 eden, survivor, old 등으로 할당하여 각 영역이 가득 차게 될 경우에만 GC를 작업합니다. 여유가 있는 힙 메모리를 사용할 때 효과적입니다.

#### Z GC: G1 과의 차이점으로 고정적이던 region 영역이 Z page 단위로 바뀌어 2MB 배수 단위로 동적으로 크기를 설정할 수 있는 방법입니다. 힙의 메모리가 아무리 증가하더라도 STW를 10ms 이내로 줄이려는 개발 목적이 있습니다.



### 자바 버전 별 기본GC

* Java 8: Parallel GC
* Java 9 이상 : G1 GC (작성 기준 java 21 까지)
