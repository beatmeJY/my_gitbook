---
description: 🍇🍈🍉🍊🍋🍌🍍🥭🍎🍏🍐🍑🍒🍓🥝🥑
---

# ☕ JAVA

## 🦾 컴파일 & 메모리

### 🍇 자바는 컴파일언어일까 인터프리터 언어일까?

자바는 컴파일과 인터프리터 두 방식을 모두 사용하고 있습니다.

### 🍈 자바는 왜 컴파일을 할까?

* 자바는 고수준 언어에서 작성 된 Java파일을 컴파일하여 바이트 코드인 class파일로 컴파일하는 작업을 하게 됩니다.
* 이는 한번 작성한 코드를 어느 운영체제에서든 실행 가능하도록 한 자바의 목적에 의해서 JVM만 있다면 어디서든 동작이 가능하도록 JVM이 이해할 수 있는 바이트코드로 변환하기 위해 이러한 작업을 거치게 됩니다.



### 🍉 자바의 컴파일 과정은?

<figure><img src="../.gitbook/assets/image (118).png" alt=""><figcaption><p><a href="https://velog.io/@mooh2jj/JIT-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EB%9E%80">https://velog.io/@mooh2jj/JIT-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EB%9E%80</a> 참조</p></figcaption></figure>

* **javac**: 자바 컴파일러가 .Java 파일을 바이트코드인 .class파일로 컴파일합니다.
* **클래스 로더**: 컴파일된 바이트코드를 JVM으로 가져옵니다.
* **JVM**: 컴퓨터가 이해할 수 있는 기계어로 변환합니다.
  * 인터프리터: 바이트코드를 실시간으로 기계어로 변환하며 실행합니다.
  * JIT(Just-in Time) 컴파일러: 자주 사용되는 코드를 변환하여 캐싱하여 두고 재사용합니다.



### 🍊 JRE와 JDK의 차이점은?

* **JRE**는 미리 작성된 자바코드를 실행시키기 위해서만 사용되고,
* **JDK**는 JRE 기능을 포함하며 개발자가 자바를 개발하는데 사용할 수 있도록 컴파일러, jar 등을 추가로 제공합니다.



### 자바의 참조 레퍼런스 4바이트와 8바이트일 때의 차이



### byte, short, int, long, double, float, char, string boolean 메모리 할당 크기는?

* byte: 1 byte
* short: 2 byte
* int: 4 byte
* long: 8 byte
* float: 4 byte
* double: 8 byte
* char: 2 byte
* string:&#x20;
* boolean: 1 byte

### 자바의 데이터 구조



### Runtime Constant Pool과 Constant Pool 차이는?

### Constant Pool과 String Constant Pool 차이는?



## 🔠 변수

### 기본자료형이란?



### 참조자료형이란?



### Integer 값 비교시 ==를 사용하면 안되는 이유

* 우선 int는 기본 자료형이고, Integer는 참조 자료형이며 래퍼 클래스입니다.&#x20;
* 따라서 기본 자료형끼리만 비교할 경우 문제가 되지 않지만, 래퍼 클래스끼리 비교하게 될 경우 equals() 메서드를 통해 같은 참조를 비교하는 것이 아닌 실제 값을 비교해주어야 합니다.
* 다만, -128 \~ 127의 범위에 값에 대해서는 Integer 클래스 내부에 캐싱된 값을 가지고 있으므로 == 로 비교하여도 동일한 주소를 참조해 결과가 동일하게 나올 수 있습니다.

### 맴버 변수란?

#### 클래스 변수

* 해당 클래스에 모든 인스턴스에서 공유 되어 사용 가능한 값입니다.
* 객체가 아닌 클래스의 상태를 나타내는 값입니다.
* 전역변수의 성질을 가지고 있습니다.

```java
public class Zoo {
    static int animalCount = 0; // 클래스 변수
}

class Test {
    void testMethod() {
        Zoo.animalCount++;
    }
}
```

#### 인스턴스 변수

* 인스턴스(객체)의 상태를 나타낼 수 있는 값입니다.
* 객체를 생성할 때마다 새로운 인스턴스 변수가 메모리에 할당됩니다.
* 때문에, 객체(인스턴스)를 생성 해야지만 사용할 수 있습니다.

```java
public class Zoo {
    int animalCount = 0; // 인스턴스 변수
}

class Test {
    void testMethod() {
        Zoo animalCount = new Zoo();
        animalCount++;
    }
}
```



### 지역 변수란?

* 메소드 내에 선언되며 메소드 내에서만 사용 가능한 변수 입니다.
* 보통 메소드가 종료되면 함께 소멸합니다.

```java
public class Zoo {
    void testMethod() {
        int animalCount = 0; // 지역 변수
    }
}
```



### 전역 변수 VS 맴버 변수

* 가끔자바에서는 흔히 이 두 가지 용어를 혼용하여 동의어처럼 사용하기도 합니다.
* 하지만 **맴버 변수**의 경우 두 가지 변수를 포함하는 개념인데,
  * 먼저, 클래스 변수는 클래스 전체 범위(모든 인스턴스)에서 접근이 가능하여 동일한 개념이지만,
  * 인스턴스 변수는 각 인스턴스 별로 다른 변수 값을 가지게 되므로 다르다고 볼 수 있습니다.
* 때문에 결과적으로는 실제 두 개념이 다르다는 것을 **꼭** 인지해야 합니다.

#### 📚 참고자료

* [Integer "==" 비교에 대한 글](https://dzone.com/articles/java-integer-cache-why-integervalueof127-integerva)



### 래퍼 클래스 캐싱 범위

* **Integer, Long, Short** : -128 \~ 127 범위까지 만
* **Byte**: 전체 범위 (-128 \~ 127)
* **Character**: 0 \~ 127 범위까지 만

단, JVM의 -XX:AutoBoxCacheMax 옵션으로 캐싱 값 범위를 변경할 수는 있지만 Integer만 변경할 수 있다.



## 🧩 객체 지향

해결해야 할 문제 상황에 대하여 데이터와 이 데이터를 사용하는 기능을 하나의 객체로 묶어 책임을 분리하고 이러한 객체들의 협력적인 관계를 통해 문제를 해결하는 프로그래밍 패러다임입니다.

### 왜 데이터와 기능이 하나의 객체에 존재해야 할까?

이렇게 하는 이유는 크게 **응집성**과 **캡슐화**를 설명 드릴 수 있을 것 같습니다.

* **응집성:** 데이터와 해당 데이터를 사용하는 기능이 함께 객채에 존재하게되면 응집성이 높다고 볼 수 있습니다. 이렇게 응집성이 높아지면 코드를 이해하기가 쉽고 유지보수성이 높아지게 됩니다. 또한 이렇게 잘 응집된 객체는 책임이 잘 분리되어 재사용성이 높아지게 됩니다.
* **캡슐화:** 이렇게 하나의 객체 안에서 데이터와 역할이 함께 존재하게 된다면, 외부에서는 해당 객체에 직접적인 기능을 정의하지 않고 인터페이스에만 의존할 수있게 되어 데이터의 일관성을 보장할 수 있게되고, 또한 수정 사항이 발생 시 외부에선 인터페이스에만 의존하기 떄문에 수정사항이 전파되지 않는 장점을 얻을 수 있습니다.



### 객체 지향 프로그래밍의 장점은?

* 다형성과 캡슐화를 통해서 내부의 수정사항이 발생하더라도 외부에선 인터페이스에만 의존하고 있기 때문에 수정이 전파되지 않아 유지보수에 용이하고,
* 각 객체별로 책임 잘 분리가 되어있다면 코드의 재사용성이 높아지게 됩니다.
* 이는 또한 단위 테스트를 작성할 때에도 각 기능에 대해 독립적으로 테스트 할 수 있어 버그를 잡아내는데 더욱 유리합니다.

### 객체 지향 프로그래밍의 단점은?

* 절차 지향 프로그래밍에 비해 속도가 조금 느릴 수 있습니다. 이는 객체지향은 모든 것을 객체로 보기 때문에 이를 생성하고 소멸시키며 포인터 크기에 대한 메모리와 연산에 대한 비용이 들게 됩니다.
* 많은 추상화를 진행하다보면&#x20;
* 설계에 대한 비용과 이를 이해하기 위한 학습 곡선이 높을 수 있습니다.



### 추상화란?

### 다형성이란?

### 상속이란?

### 캡슐화란?





## 🗑️ 가비지 컬렉터 (GC)

### Minor GC란?



### Major GC란?



### Garbage 판단 기준

* 힙 내에서 다른 객체에 의한 참조
* Java 스택에 의한 참조 (Java 메서드 실행 시 사용하는 지역변수나 파라미터 변수)
* JNI에 의한 참조 (Java Native Interface에서 생성한 객체)
* Method Area의 static 변수에 의한 참조



### 자바 버전 별 기본GC

* Java 8: Parallel GC
* Java 9 이상 : G1 GC (작성 기준 java 21 까지)

### 각 GC 별 차이

#### Parallel GC:

#### G1 GC:

#### Z GC:

