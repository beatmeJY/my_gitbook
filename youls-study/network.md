# 🌐 Network

## 🛜 OSI-7계층

### TCP와 UDP의 차이에 대해 설명해주세요.

<div align="left">

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1).png" alt="" width="375"><figcaption><p><a href="https://nordvpn.com/ko/blog/tcp-udp-comparison/">이해를 돕기 위한 TCP 그림</a></p></figcaption></figure>

 

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1).png" alt="" width="375"><figcaption><p><a href="https://nordvpn.com/ko/blog/tcp-udp-comparison/">이해를 돕기 위한 UDP 그림</a></p></figcaption></figure>

</div>

|             |                         🔒 TCP                        | ⏩ UDP |
| :---------: | :---------------------------------------------------: | :---: |
|     패킷헤더    |                          큰 헤더                         | 경량 헤더 |
|   연결 및 해제   | <p>연결: 3-way HandShaking<br>해제: 4-way HandShaking</p> | 하지 않음 |
|    순서 보장    |                           함                           |  안 함  |
|  데이터 무결성 체크 |                           함                           |  안 함  |
|     신뢰성     |                           높음                          |   낮음  |
| 손상된 패킷 도착 시 |                       패킷 재 전송 요청                      | 패킷 폐기 |
|      속도     |                         비교적 느림                        |   빠름  |



### 패킷의 순서가 꼬여서 도착하면 어떻게 할까요?

* TCP는 순서가 꼬여서 들어오게 되면 데이터가 도착하는 순서를 보장하기 위해 OS가 수신한 데이터를 버퍼에 저장하고, 이를 TCP 스택을 통해 순서대로 조립하여 상위 계층으로 전송합니다.
* UDP는 순서를 보장하지 않으므로 만약에 순서가 꼬였더라도 어플리케이션 계층에서 직접 처리를 해야합니다.

### UDP는 왜 빠를까요?

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* UDP는 우선 연결하거나 종료할 때 발생하는 비용인 3way/4way HandShaking 과정이 없으며,
* 전달하는 서버나 받는 서버 모두 데이터가 정합성을 검증하지 않아 작은 헤더로 구성 할 수 있고,
* 그로 인해 클라이언트와 연결 후 전송하는 1:1방식의 Unicast인TCP와는 달리
* 서버에서 여러 클라이언트로 1:M 방식인 Broadcast 또는 Multicast 방식으로 전송할 수 있게 되어 훨씬 빠르고 효과적으로 전송할 수 있게 됩니다.

### UDP를 어디에 사용할 수 있을까요?

* UDP는 보통 게임, 스트리밍, 영상시청 등과 같은 신뢰성보다 신속한 데이터 전송이 우선 시 되는 경우에 사용됩니다.
* 예를 들어 동영상을 시청할 경우 데이터가 손실이 발생하더라도 동영상이 끊길 뿐 치명적인 시스템 오류로 이어지지는 않습니다.
* 따라서 속도가 중요한 실시간 라이브, 게임환경 등을 전송 받기 위해서는 속도에 집중되어있는 UDP를 사용하는 것이 좋습니다.

### TCP Checksum에 대해서 설명해주세요.

* 우선TCP의 Checksum은 TCP 패킷의 모든(헤더와 바디) 데이터들을 16bit단위로 변환을 합니다.
* 그 후 모든 bit를 합쳐 1의 보수값을 취한 뒤 Checksum에 넣어 패킷을 전송할 때 같이 전송합니다.
* 이를 받은 클라이언트는 동일하게 body의 모든 값을 16bit 단위로 변환한 후 모두 합친 뒤,
* 체크섬 값을 더하여 모든 값이 1로 나오는지 확인하여 쉽고 빠르게 패킷의 손상 여부를 확인할 수 있습니다.

#### 📖 추가로 보면 좋은 내용

* **체크섬 오프로드 란?**
  * 원래는 OS를 통해 CPU가 TCP의 체크섬을 계산하지만,
  * 최근의 네트워크 카드들에서 직접 체크섬을 계산하도록 하여 CPU 성능을 향상 시키는 방법입니다.
* [체크섬 오프로드 해제하는 방법](https://myknowledge.kr/29)

### LAN과 WAN의 차이에 대해서 설명해주세요.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="563"><figcaption><p><a href="https://www.cloudflare.com/ko-kr/learning/network-layer/what-is-a-wan/">https://www.cloudflare.com/ko-kr/learning/network-layer/what-is-a-wan/</a></p></figcaption></figure>

#### LAN

* LAN은 로컬 네트워크에서 통신할 경우 주로 사용되며,
* 주로 이더넷을 사용한 학교 등에서 사용됩니다.
* 일반적으로 제한된 영역 내에서 사용되며 때문에 높은 전송 속도와 대역폭을 가질 수 있습니다.
  * (쉽게 생각하면 군대나 학교에서 스타나 워크를 로컬플레이 하던 것이라 생각하면 쉽습니다.)

#### WAN

* WAN은 외부 네트워크와 통신할 때 주로 사용 되며,
* 주로 인터넷을 사용하여 ISP 등을 통해 도시, 국가 간에서 사용됩니다.
* 일반적으로 넓은 영역 내에서 사용되어 비교적 낮은 전송 속도와 대역폭을 가질 수 있습니다.

### 네트워크 계층 vs 전송 계층

#### 네트워크 계층

* 네트워크 계층은 IP을 담당하는 계층으로 주로 라우터 등 인터넷을 사용하는 계층입니다. 다.
* 네트워크 간 연결에 관련된 일은 모두 네트워크 계층에서 일어납니다.
  * 데이터 패킷이 취할 경로를 설정하는 일
  * 다른 네트워크 서버가 가동 중인지 확인하는 일
  * IP 패킷에 주소를 붙이고, 다른 네트워크로부터 IP 패킷을 수신하는 일 등

#### 전송 계층

* 전송 계층은 주로 Port 등을 담당하는 계층으로 주로 TCP, UDP을 사용 하는 계층입니다.
* 컴퓨터 네트워크에서 데이터를 보내고 프로세스 간의 통신을 관리하는 계층입니다.
* 여러 응용 프로그램이 한 컴퓨터에서 동작하고 있을 때 포트 번호를 통해 올바른 프로세스로 전달 할 수 있게 됩니다.

### 라우터 vs 스위치

<figure><img src="../.gitbook/assets/image (107).png" alt=""><figcaption><p><a href="https://coding-chobo.tistory.com/38">https://coding-chobo.tistory.com/38</a></p></figcaption></figure>

#### 라우터

* 라우터는 3계층의 네트워크 계층에 속합니다.
* 주로 IP를 사용하여 각 장치에 전달하는 등 네트워크 간의 라우팅을 수행합니다.
* 서로 다른 프로토콜로 운영하는 통신망 사이에서 정보를 전송하기 위해 경로를 설정하는 역할을 하는 핵심적인 장비입니다.
* 수신된 패킷에 의하여 자신이 연결되어있는 통신망 내의 노드를 결정하여 가장 효율 적인 경로를 선택하여 패킷을 전송해줍니다.

#### 스위치

* 스위치는 주로 2계층인 데이터링크 계층에 속합니다.
* 주로 MAC 주소를 사용하여 통신하고 이더넷을 기반으로 통신하여 장치 간의 통신을 수행합니다.
* 스위치는 자신에게 연결된 모든 디바이스들의 MAC 주소와 포트가 기록된 MAC 주소 테이블을 가지고 있습니다.
* 만약 자신의 테이블에 없는 목적지를 가진 패킷이 오면 연결된 모든 장치에 포워딩을 합니다. (= 허브와 동일)

### 스위치 vs 허브

<figure><img src="../.gitbook/assets/image (106).png" alt="" width="563"><figcaption><p><a href="https://codebox-j.tistory.com/56">https://codebox-j.tistory.com/56</a></p></figcaption></figure>

#### 허브

* 허브는 1계층에서 동작하고 허브는 통신 할 경우 브로드캐스팅을 통해 연결되어 있는 모든 장치에게 전달해야합니다.
* 허브는 모든 장치에 전송하므로 많은 충돌이 일어날 수도 있습니다.

#### 스위치

* 스위치는 주로 2계층에서 동작하며 MAC 주소를 기반으로 정확한 목적지에만 전송합니다.
* 때문에 허브보다 보안에도 좋고 비용도 훨씬 아낄 수 있으며,
* 스위치는 충돌이 일어날 확률이 더 낮아집니다.

최근에는 스위치의 가격도 많이 낮아져서 허브를 쓰는 대신 스위치로 주로 사용하고 있다고 합니다.

### OSI 각 층의 장비에 대해서 설명해주세요.

* 1계층 모뎀, 리피터
* 2계층 스위치
* 3계층 라우터
* 4계층 게이트웨이
* 5계층 세션관리서버 등(응용 계층에서 이루어짐)
* 6계층 응용계층에서 이루어짐
* 7계층 웹 서버, DNS 서버 등

### L2, L3, L4, L7 각 스위치 차이를 설명해주세요.

* L2의 스위치는 주로 사용되는 스위치의 영역으로 MAC 주소를 기반으로 이더넷을 전달할 때 사용됩니다.
* L3의 스위치는 IP 주소를 기반으로 패킷을 라우팅 하며 라우터의 기능까지 수행하는 스위치를 일컫습니다.
* L4의 스위치는 주로 TCP, UDP 포트 번호를 기반으로 동작 하는 스위치를 일컫습니다. L4에서는 간단한 로드 밸런싱, 프로토콜 변환 등을 수행합니다.
* L7 스위치는 어플리케이션 레이어에서 로드 벨런싱, 웹 어플리케이션 방화벽 등과 같은 고급 기능을 수행할 때 일컫습니다.

## 🕸️ 웹 (web)

### 웹이란 무엇일까요?

* 웹이란 WWW(World Wide Web)의 줄임말로, 인터넷에 연결된 전세계 사용자들이 서로의 정보를 공유할 수 있는 장소를 의미합니다.
* 웹은 전자 메일과 같이 인터넷 상에서 동작하는 **하나의** **서비스** 일 뿐이지만, 1993년부터 현대까지 웹은 인터넷 구조의 절대적 위치를 차지하고 있습니다.
* 웹에는 수많은 **웹사이트**들이 있고 각각의 웹사이트는 **웹페이지**로 구성되어 있습니다.
* **추가 키워드**
  * **웹 서비스** 란?
    * 흔히 인터넷에 연결된 전 세계 컴퓨터들의 모든 문서들을 연결하여 언제 어디서든지 정보 검색을 가능하게 해주는 서비스를 말합니다.
  * **웹 페이지** 란?
    * HTML 언어를 사용하여 작성된 하이퍼텍스트 문서를 웹 페이지라고 부릅니다.
  * **웹 사이트** 란?
    * 이러한 웹 페이지들 중에서 서로 관련된 내용으로 작성된 웹 페이지들의 집합을 웹 사이트라고 부릅니다.
  * **웹 브라우저** 란?
    * 사용자가 웹 페이지를 검색하고 컴퓨터로 불러와 실행하기 위해 사용하는 응용 프로그램을 웹 브라우저라고 합니다.

### URI, URL, URN의 차이에 대해서 설명해주세요

<figure><img src="../.gitbook/assets/image (75).png" alt=""><figcaption><p><a href="https://danielmiessler.com/p/difference-between-uri-url/">https://danielmiessler.com/p/difference-between-uri-url/</a></p></figcaption></figure>

#### **URI** (Uniform Resource Identifier)

<figure><img src="../.gitbook/assets/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

* 통합 자원 식별자로 인터넷 자원을 나타내는 유일한 주소입니다.
* URI의 하위 개념으로 URL과 URN이 있습니다.
* 쉽게 생각해서 어떠한 주소가 URL이 아니고 URN도 아니더라도 어떤 형태로든 리소스를 식별 할 수 있다면 URI입니다.

#### **URL** (Uniform Resource Locator)

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* 통합 자원 위치로 자원이 어디에 있는지 위치를 알려주기 위한 규약입니다.
* URL은 웹 사이트 주소뿐만 아니라 컴퓨터 네트워크 상의 자원을 모두 나타내는 표기법입니다.
* 쉽게 생각해서 **프로토콜과 리소스**를 **모두 포함** 한다고 생각하면 좋습니다.

#### **URN** (Uniform Resource Name)

* 자원 이름으로 웹 문서의 물리적인 위치와 상관없이 웹 문서 자체를 나타냅니다.
* 쉽게 말해 리소스를 어떻게 접근할 것인지 명시하지 않고 경로와 **리소스 자체를 특정**하는 것 입니다.

<figure><img src="../.gitbook/assets/image (76).png" alt=""><figcaption><p><a href="https://danielmiessler.com/p/difference-between-uri-url/">https://danielmiessler.com/p/difference-between-uri-url/</a></p></figcaption></figure>

즉, 정리하자면

* URI는 URL과 URN을 포함하고 있어 둘 중 무엇으로도 볼 수 있고,
* URL은 프로토콜을 포함한 리소스의 위치를 나타내며,
* URN은 리소스의 위치를 나타내지 않고 리소스의 고유한 이름을 나타내는 것 입니다.



### Stateless 이란?

* 상태유지를 하지 않는(무상태) 방법입니다.
* 무상태란 클라이언트와 서버 사이에서 서버가 클라이언트의 상태를 보존하지 않는 것입니다.
* 쉽게 말해 서버가 상태를 기억하지 않으므로 클라이언트가 통신에 필요한 모든 정보를 통신 할 때 마다 실어서 보내는 것입니다.
* 클라이언트가 통신할 때마다 모든 정보를 보내야 하는 단점이 있지만, 서버의 자원을 아낄 수 있고 여러 서버를 사용하는 서버에서도 상태를 기억하고 있지 않기 때문에 어느 서버든 요청을 처리 할 수 있습니다.

### Stateful 이란?

* 상태 유지를 하는 방법입니다.
* 상태 유지란 클라이언트와 서버 사이에서 서버가 클라이언트 상태는 보존하는 것입니다.
* 쉽게 말해서 서버가 상태를 기억하므로 클라이언트는 이전 요청에서 제공한 값을 다음번 요청에서도 사용 할 수 있습니다.
* stateful의 문제는 서버가 여러 서버를 사용할 때 원래 통신하던 서버에 오류가 발생 시 기억된 상태가 없어져서 다른 서버에서도 처리 할 수 없습니다.
  * 예를 들어 로그인을 하고 상품을 결제 하려는데 사용자 정보가 사라짐.



### 사용자 요청에서 어떻게 사용자를 구분 할 수 있을까?

#### **간단하게 식별하기 위해서는**

* **IP** 를 통해 식별하는 방법과
  * IP는 좀처럼 바뀌지 않지만 동일한 IP에서 여러 사용자의 요청을 식별 할 수는 없습니다.
* **HTTP Header** 를 이용하는 방법이 있습니다.
  * **From**은 사용자의 이메일 주소가 담겨있어 이를 통해 사용자를 식별 할 수 있습니다.
  * **User-Agent**는 사용자가 사용 중인 브라우저 이름, 버전을 포함하므로 이를 통해 식별 할 수 도 있습니다.
  * **Referer**를 사용하여 유입하게 된 웹페이지의 URL을 확인 하는 방법도 있습니다.

#### 좀 더 정확하게 식별하는 방법에는 다음과 같은 방법들이 있습니다.

* **쿠키**
  * 서버는 클라이언트에게 임의에 쿠키 값을 넣어 전송하고 클라이언트는 다시 전송할 때마다 해당 쿠키의 값을 전송하여 식별하는 방법입니다.
* **세션**
  * 클라이언트에서 사용자가 로그인 시 세션을 생성하고 이 세션값을 서버에서 저장한 뒤 쿠키 등에 넣어 전달하여 클라이언트를 식별하는 방법입니다.
* **JWT**
  * JWT는 서버에 상태를 저장하지 않아 무상태(StateLess)하게 사용자를 식별할 수 있습니다. 따라서 서버의 확장성, 성능, 인증서버와 리소스서버 분리 등 다양한 장점을 얻을 수 있습니다.



### REST API 란 무엇일까요?





### PUT과 PATCH의 차이에 대해 설명해주세요

* PUT와 PATCH는 일반적으로 리소스의 업데이트를 위한 HTTP 메서드로 사용되지만 가장 큰 차이점은 PUT은 전체를 업데이트(덮어쓰기) 하는 반면 PATCH는 일부만(바뀐내용만 수정) 업데이트를 합니다.
* 따라서 PUT과 PATCH는 멱등성을 가지는것이 원칙이지만 PATCH의 경우는 상황에 따라 보장되지 않을 수도 있습니다.



### DNS Round Robin에 대해 설명해주세요.

* 신뢰할 수 있는 DNS서버에서(도메인을 호스팅 하는) 이루어지며 여러 서버가 동일한 도메인을 가르킬 경우 RR 알고리즘을 통해 다른 IP 주소로 할당해주는 방법입니다.
* 단점으로는 트래픽을 고르게 분산하기 위해 여러 IP를 사용하는 것이지만 클라이언트가 DNS캐시를 재사용할 경우 발생할 수 있는 트래픽 부하, 재갱신 오류 등이 발생 할 수 있고
* Round Robin DNS는 실제 로드밸런싱이 하는 백앤드서버의 헬스체크와 같은 작업을 하지 못하여 서버의 상태를 알지 못하므로 오류가 발생한 서버가 있어도 DNS조회 결과에 반영될 수 있습니다.



### DNS Resolver에 대해 설명해주세요.

* 사용자가 도메인 이름을 입력했을 때 사용자의 컴퓨터나 네트워크 장치에서 DNS 쿼리를 생성하고 해당 쿼리를 DNS서버에 연결하여 전송한 뒤 응답을 받아오는 소프트웨어 또는 서비스 입니다.
* DNS Resolver는 일반적인 사용자나 소규모 네트워크에서는 주로 OS나ISP의 공유기에 내장되어 있습니다.



### DNS 재귀적 질의와 반복적 질의에 대해 설명해주세요.

#### **재귀적(Recursive) 질의란**

* 사용자의 클라이언트(웹 브라우저)가 DNS 서버에게 특정 도메인 이름에 대한 IP 주소를 찾도록 요청합니다.
* DNS 서버는 이 요청을 받으면, 해당 도메인 이름에 대한 IP 주소를 찾을 때까지 계속해서 다른 DNS 서버에게 질의를 전달합니다.
* DNS 서버는 최종적으로 IP를 찾아 클라이언트에게 반환합니다.

#### **반복적(Iterative) 질의란**

* 클라이언트가 DNS 서버에게 도메인 이름에 대한 IP 주소를 물어봤을 때 정보를 가지고 있다면 해당 주소를 주고 없다면 해당 도메인에 대한 정보를 질의할 수 있는 다른 DNS 서버의 주소를 제공합니다.
* 클라이언트는 이후 질의를 위해 반복하여다른 DNS 서버에 직접적으로 접근하며 정보를 얻어야 합니다.
* 이 과정이 반복되면서 최종적으로 클라이언트가 요청한 도메인에 대한 IP 주소를 찾습니다.

#### 🍀 정리하자면

* **재귀적 질의**는 DNS 서버에 한번만 질의하면 DNS 서버가 대신해서 그 질문에 대한 답을 끝까지 찾아 주므로 사용자 친화적이고,
* **반복적 질의**는 DNS 서버가 다른 DNS 서버를 알려주고 클라이언트가 직접적으로 반복하여 결과를 얻을 때 까지 질의를 해야 하므로 편리성이 떨어질 수 있으나 대규모 트래픽이 발생하는 경우엔 DNS 서버의 부하를 줄일 수 있습니다.



### DNS에서 사용되는 프로토콜은 어떤 걸까요?

* DNS의 프로토콜은 일반적으로 UDP를 사용합니다.
  * 이는 연결지향이 아니며 속도가 빠르고 간단하기 때문입니다.
  * 또한 DNS쿼리에서 패킷 손실이 발생하더라도 큰 문제가 되지 않습니다.
* TCP를 이용하는 경우
  * 대규모 쿼리나 DNS 쿼리의 응답 크기가 512Byte를 초과하는 경우 사용됩니다.
    * 이는 어떠한 경우에 초과할까요? (DNS 메시지는 아래 추가 정보들이 포함 될 수 있습니다.)
      * **응답 섹션(Answer Section):** 실제로 찾은 도메인의 IP 주소 등
      * **권한 섹션(Authority Section):** 찾은 정보에 대한 권한이 있는 DNS 서버의 정보
      * **추가 섹션(Additional Section):** 이는 주로 캐싱을 위한 정보를 담습니다.



### 멱등성에 대해 설명해주세요.

* 멱등성이란 어떤 작업이 여러 번 수행 되더라도 결과가 변하지 않는 성질을 말합니다.
* 쉽게 말해서 같은 작업을 여러번 시도하더라도 항상 처음과 결과가 동일해야 합니다.
* 예를 들어
  * 위에서 설명 드렸던 동일한PUT(PATCH) 메서드의 멱등성 보장과,
  * DB에서는 한 트랜잭션 내에서의 동일한 정보를 (수정없이) 여러 번 조회 시 항상 같은 값을 반환해야 하는 성질들도 멱등성이 필요한 상태라고 볼 수 있습니다.



## 🍪 쿠키와 세션

### 쿠키와 세션을 사용하는이유

* HTTP는 비연결성으로 서버에 요청을 전송할 때에는 항상서버와의 새 연결을 진행해야 합니다.
* 따라서 이전 요청에 대해서는 새로운 연결 요청이 이루어지게 되므로 기억하고 있지 않습니다.
* 그걸 위해 쿠키나 세션을 사용하게 되면 이전 요청에서의 정보를 기억하여 사용자는 로그인 등을 다시 진행하지 않고 해당 정보 등을 함께 전송하여 매 요청마다 번거로운 작업을 피하고 더 유용하게 사이트를 활용 할 수 있게 됩니다.



### &#x20;세션의 저장 방식

* **서버 메모리 기반 세션 저장:**
  * 세션 데이터를 서버의 메모리에 저장합니다.
  * 빠른 응답 시간을 제공하지만 서버 재시작 시 세션 데이터가 손실됩니다.
  * 단일 서버 환경에서 사용 할 수 있는 방법입니다.
* **데이터베이스 기반 세션 저장:**
  * 세션 데이터를 데이터베이스에 저장합니다.
  * 서버 재시작에도 세션 데이터를 보존할 수 있습니다.
  * 더 안정적이지만 데이터베이스에 대한 I/O 비용이 추가될 수 있습니다.
  * 다중 서버 간 세션 공유가 가능합니다.
* **캐시 기반 세션 저장:**
  * 세션 데이터를 캐시에 저장합니다.
  * Redis 또는 Memcached와 같은 분산 캐싱 시스템을 활용할 수 있습니다.
  * 빠른 응답과 영속성을 동시에 제공합니다.
  * 다중 서버 간 세션 공유가 가능합니다.



### 세션이 날아가면 어떻게 해야할까?

* 우선 세션 정보가 없다면 공통적으로 재 로그인을 통해 세션을 다시 발급을 받는 로직을 작성을 해야할 것 같습니다.
* 이 때 사용자에게 "일시 장애를 통한 오류로 재 로그인을 부탁드린다"는 메시지 등을 잘 전달하여 사용자 경험을 향상 시키고
* 해당 예외발생 로직에 로깅을 하고 로그를 통해 발생한 경위를 최대한 추적하여 반복하여 발생하지 않도록 막는 것이 중요할 것 같습니다.



### 쿠키의 단점에 대해 설명해주세요

* **보안상의 위험**
  * 쿠키의 대표적인 단점으로는 저장위치가 클라이언트(사용자 로컬)에 위치하여 보안상의 위험이 존재한다는 것입니다. 이는 쿠키에개인적인 정보 등 보안에 위험한 데이터를 포함한다면 악성 사용자가 정보를 수정 및 탈취하여 위협을 할 수 있습니다.
* **쿠키 크기 제한**
  * 브라우저마다 다르지만 보통 최대 4KB로 많은 양의 데이터를 쿠키에 저장 할 수 없습니다.
* **성능 저하**
  * 또한 쿠키의 양이 많고 매 요청마다 모든 쿠키가 전송된다면 성능저하 문제도 발생 할 수 있습니다.



### 쿠키와 세션 차이점

#### 쿠키

* 쿠키는 클라이언트의 로컬에 저장이 되어 참조되며 키와 값으로 저장되는 작은 데이터 파일입니다.
* 사용자 인증이 유효한 시간을 명시할 수 있고 유효 시간이 경과되면 삭제됩니다.
* 유효시간이 경과 되지 않았으면 브라우저가 종료 되더라도 유지가 됩니다.
* 주로 사용자 설정 및 추적 정보(행동, 검색 기록 등) 등을 저장하는데 사용됩니다.

#### 세션

* 세션은 서버측에 저장이 되고 클라이언트에는 세션을 식별할 수 있는 ID만 가지고 있습니다.
* 서버에 저장되므로 쿠키에 비해선 보안에 덜 취약하지만 세션ID를 안전하게 관리하지 못하면 세션 역시 보안 문제가 발생 할 수 있습니다.
* 쿠키에 비해 세션은 서버 메모리에 저장하므로 더 많은 데이터를 저장할 수는 있습니다.
* 일반적으로 브라우저를 닫거나 일정 시간 동안 활동이 없을 경우 소멸됩니다.
* 주로 세션을 사용하는 동안 유지되어야 하는 사용자 로그인 정보 등을 저장합니다.



### 쿠키와 세션을 조작할 수 있는데 어떻게 해야할까

* 주로 쿠키와 세션을 조작하는 것은 악의적인 사용자가 보안을 위협하는 행위로 간주됩니다.
* 그러므로 쿠키에는 중요한 데이터 정보를 담지 않아야 합니다.
* 세션키도 탈취 당할 가능성이 있으므로 서버에서 세션에 민감한 정보를 저장하지 않아야 하며,
* 세션의 유효시간을 적절하게 설정해주어야 하고
* 쿠키와 세션의 사용에 대한 최소한의 필요성만 고려하여 설계해야 합니다.



## 🪙 JWT

### JWT를 사용하는 이유

* 서버의 상태를 저장하지 않고도 여러 서비스 간에 사용자 인증을 활용할 수 있어 효율적인 분산 시스템에서 유용합니다.
* 모바일 애플리케이션 및 웹 애플리케이션 등 다양한 도메인에서 JWT를 통해 안전하게 정보를 교환 할 수 있습니다.
* 간결하고 경량적인 형식으로 표현이 가능해서 HTTP 헤더에 포함하여 쉽게 전송 가능합니다.
* 클레임(claim)이라는 정보를 포함 할 수 있어서 사용자의 식별 정보, 권한 등을 토큰에 포함 시켜 전달 할 수 있습니다.



### JWT의 단점

* 토큰이 한번 발급 되면 변경이 불가능 하므로 내용을 변경하거나 취소하려면 서버에서 토큰을 검증하고 갱신하는 방법이 필요합니다.
* 토큰은 클레임, 서명 등 많은 정보를 포함하므로 상당한 크기가 될수 있어 매 요청에 포함될 경우 네트워크 부하를 유발 할 수 도 있습니다.
* 토큰이 탈취 당하거나 XSS 등의 스크립트 공격에 취약할 수 있습니다.
