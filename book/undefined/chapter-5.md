---
description: 레디스를 캐시로 사용하기
---

# Chapter 5

## 캐시란?

***

> 캐시란 데이터의 원본보다 더 빠르고 효율적으로 액세스할 수 있는 임시 데이터 저장소를 의미한다.

### 캐시를 도입했을때 성능을 효과적으로 개선할 수 있는 상황

* 원본 데이터 저장소에서 원하는 데이터를 찾기 위해 검색하는 시간이 오래 걸리거나, 매번 계산을 통해 데이터를 가져와야 한다.
* 캐시에서 데이터를 가져오는 것이 원본 데이터 저장소 데이터를 요청하는 것보다 빠르다.
* 캐시에 저장된 데이터는 잘 변하지 않는 데이터다.
* 캐시에 저장된 데이터는 자주 검색되는 데이터다.
* 서비스 구성에 따라 다르지만 원본 데이터 저장소에 문제가 발생해 접근 할 수 없는 상황에서도 캐시에서 데이터를 가지고 올 수 있기 때문에 장애 시간을 일부줄일 수도 있다.



## 캐시로서의 레디스

***

### 캐시로서의 장점

#### 레디스는 사용이 간단하다.

* 단순하게 키-값 형태로 저장하므로 데이터를 저장하고 반환하는 것이 굉장히 간단하다.
* 자체적으로 다양한 자료 구조를 제공하기 때문에 어플리케이션에서 사용하던 `list`, `hash` 등의 자료 구조를 변환 없이 레디스에 바로 저장 할 수도 있다.

#### 레디스는 인메모리 데이터 저장소이기 때문에 빠르다.

* 모든 데이터를 메모리에 저장하기 때문에 데이터를 검색하고 반환하는 것이 상당히 빠르다.
* 평균 읽기 및 쓰기 작업 속도가 1ms 미만이며, 초당 수백만 건의 작업이 가능함을 의미한다.
* 이에 반해 관계형 데이터베이스에서는 테이블의 특정 데이터를 찾으려면 우선 디스크에 접근해 데이터를 검색해와야 한다.

#### 레디스는 자체적으로 고가용성 기능을 가지고 있는 솔루션이다.

* 캐시 저장소도 일반적인 데이터 저장소와 같이 안정적으로 운영이 되어야 한다.
* 레디스의 센티널 또는 클러스터 기능을 사용하면 마스터 노드의 장애를 자동으로 감지해 페일오버를 발생시킨다.
* 때문에 운영자의 개입 없이 캐시는 정상으로 유지될 수 있어 가용성이 높아진다.

#### 레디스의 클러스터를 사용하면 캐시의 스케일 아웃 또한 쉽게 처리할 수 있다.

* 서비스의 규모에 따라 캐시 자체의 규모도 늘어아야 한다.
* 이는 자체 샤딩 솔루션인 클러스터를 사용하면 수평 확장이 굉장히 간단해진다.

### 캐싱 전략

> 캐시로써 레디스를 어떻게 배치할 것인지에 따라 서비스의 성능에 큰 영향을 끼칠 수 있다.
>
> 따라서 캐싱 전략은 캐싱되는 데이터의 유형과 데이터에 대한 액세스 패턴에 따라 적절한 캐싱전략을 선택하는 것이 중요하다.

#### 읽기 전략 (look aside)

* 어플리케이션에서 데이터를 읽어갈 때 주로 사용하는 읽기 전략은 레디스를 캐시로 사용할 때 가장 일반적으로 배치하는 방법이다.
* 데이터가 먼저 캐시에 있는지 확인 한 후 있을 경우 반환하고,
* 없을 경우 `캐시 미스`가 발생해 원본 데이터베이스에 접근하여 데이터를 가져와 다시 캐시에 저장하는 과정을 거치게 됩니다.
* 장점:&#x20;
  * 레디스에 문제가 생겨 접근 할 수 없는 상황이 발생하더라도 장애로 이어지지 않고 원본 데이터베이스에서 데이터를 가져 올 수 있다.
* 단점:
  * &#x20;그로인해 원본 데이터베이스의 응답이 느려지거나 리소스를 많이 차지하는 등의 이슈가 발생할 수 있다.
  * 캐시 미스가 일어날 경우에도 레디스에 매번 먼저 접근하므로 지연이 초래 되어 성능에 영향을 미칠 수 있다.
* 이러한 단점을 극복하기 위해 `캐시 워밍`이라는 최초 데이터를 밀어 넣어주는 작업을 한다.

#### 쓰기 전략 (캐시 일관성)

> 데이터가 변경될 때 원본 데이터베이스에만 업데이트 되어 캐시에는 반영되지 않는다면 데이터 간 불일치가 일어나 `캐시 불일치`가 발생한다.

#### 1. write through

* 데이터 베이스에 업데이트 할 때마다 매번 캐시에도 데이터를 함께 업데이트 시키는 방식이다.
* 캐시는 항상 최신 데이터를 가지고 있다는 장점이 있지만,
* 데이터는 매번 2개의 저장소에 저장되어야 하기 때문에 데이터를 쓸 때마다 시간이 많이 소요 된다.

#### 2. cache invalidation

* 데이터베이스에 값을 업데이트 할 때마다 캐시에서는 데이터를 삭제하는 전략이다.
* 삭제하는 것이 새로 저장하는 것보다 훨씬 리소스 소모량이 적기 때문에 `write through`의 단점을 보완한 방법이라 볼 수 있다.

#### 3. write behind (write back)

* 쓰기가 빈번하게 일어나는 경우 데이터베이스에 많은 디스크 I/O를 유발해 성능 저하가 발생한다.
* 따라서 먼저 데이터를 빠르게 접근할 수 있는 캐시에 업데이트한 뒤 이후에 특정 시간 간격이나 건수 등에 따라 비동기적으로 데이터베이스에 업데이트 하는 것이다.
* 영상에좋아요 개수 등 실시간으로 정확한 데이터가 아니여도 되는 경우에 사용하면 유용할 수 있다.
* 다만 캐시에 문제가 생겨 데이터가 날아갈 경우 데이터가 날아가는 위험성은 감수 할 수 있어야 한다.



## 캐시에서의 데이터 흐름

***

> 레디스를 캐시로 사용할 때에는 데이터를 저장함과 동시에 적절한 시간의 TTL값을 지정하는 것이 좋다.

### 만료 시간

* TTL은 데이터가 얼마나 오래 저장될 것인지를 나타내는 시간 설정이다.
* 레디스는 특정 키에 대한 만료 시간을 설정할 수 있으며 일반적으로 초 단위로 표현된다.
* 특정 키에 대한 만료 시간이 설정되면 해당 키와 관련된 데이터는 지정된 시간이 지난 후 자동 삭제된다.
* 이는 임시 데이터를 처리하거나 데이터 수명을 관리하고 메모리 공간을 효율적으로 사용하는데 도움을 준다.
* 다만, 레디스에서 키가 만료되었다고 메모리에서도 바로삭제되는 것은 아니다.
  * passive 방식:&#x20;
    * 클라이언트가 키에 접근할 때 키가 만료 되었다면 삭제하는 방식이다.
    * 다시 접근하지 않는 만료된 키도 있어 최악의 경우 전체 메모리의 1/4는 만료된 키 값일 수 있다.
  * active 방식:
    * TTL 값이 있는 키 중 20개를 랜덤하게 뽑은 뒤 만료된 키를 모두 메모리에서 삭제한다.
    * 만료된 키가 25% 이하(5개)라면 이미 뽑아두었던 키 집합에서 다시 확인한다.
    * 25% 이상이라면 다시 랜덤하게 20개를 뽑아 반복한다.
    * 이러한 과정은 1초에 10번씩 수행한다.

```
SET a 100
EXPIRE a 60

INCR a
> 101
TTL a
> 51

RENAME a apple
TTL a
> 41

SET a banana
TTL a
> -1
```

* **EXPIRE**: `EXPIRE`커맨드를 이용해 만료시간을 설정할 수 있다.
* **INCR, RENAME**: 데이터를 변경하거나 키의 이름을 바꾸어도 만료시간을 변하지 않는다.
* **SET**: 기존 키에 새로운 값을 저장해 키를 덮어 씌울 경우 만료시간은 사라진다.



### 메모리 관리와 maxmemory-policy 설정

> 만료시간을 통해 데이터가 삭제하여도 메모리는 제한적이기 때문에 가득 차는 상황이 발생할 수 있다.
>
> 따라서 메모리는 초과하는 데이터가 저장되면 어떤 키를 삭제할 지 내부 정책을 결정해야 한다.

* **maxmemory**: 데이터의 최대 저장 용량을 설정하는 설정 값이다.
* **maxmemory-policy**: 초과할 때의 처리 방식을 결정하는 설정 값이다.

#### Noeviction

* `maxmemory-policy`의 기본 설정 값이다.
* 이 값은 레디스에 데이터가 가득 차더라도 임의로 데이터를 삭제하지 않고 더 이상 레디스에 데이터를 저장할 수 없다는 에러를 반환하는 설정이다.
* 하지만 개발자가 직접 지워야 하기 때문에 레디스를 캐시로 사용할 때 권장하지 않는 설정 값이다.
* 캐시 내부적 판단으로 데이터를 삭제하는 것이 위험하다고 판단될 때 이 옵션을 사용할 순 있다.

#### LRU eviction

* 가장 `최근`에 사용되지 않은 데이터부터 삭제하는 정책이다.
* **volatile-lru**:
  * 만료 시간이 설정되어 있는 키에 한해서 키를 삭제한다.
  * 삭제되면 안되는 값에 대해서는 만료 시간을 지정하지 않는다면 더 적합할 수 있다.
* **allkeys-LRU**:
  * 레디스 공식 문서에선 레디스를 캐시로 사용할 경우 잘 모른다면 해당 방식을 사용하기를 권장한다.
  * 이 방식은 모든 키에 대해 LRU 알고리즘을 이용해 데이터를 삭제하기 때문에 적어도 메모리가 꽉 차서 장애가 발생할 상황은 방지할 수 있다.

#### LFU eviction

* 가장 `자주` 사용되지 않은 데이터부터 삭제하는 정책이다.
* **volatile-lfu**:
  * 만료 시간이 설정되어 있는 키에 한해서 키를 삭제한다.
* **allkeys-lfu**:
  * 모든 키에 대해 LFU 알고리즘을 이용해 데이터를 삭제한다.

#### RANDOM eviction

* 레디스에 저장된 키 중 하나를 임의로 골라내 삭제한다.
* 삭제될 키 값을 계산하지 않아도 된다는 점에서 레디스의 부하를 줄여줄 수 있는 방법이다.
* 랜덤으로 삭제되기 때문에 자주 사용될 수 있는 데이터를 삭제한 가능성이 높아진다.
* **volatile-random**:
  * 만료 시간이 설정되어 있는 키에 한해서 랜덤하게 키를 삭제한다.
* **allkeys-random**:
  * 모든 키에 대해 랜덤하게 키를 삭제한다.

#### volatile-ttl

* 만료 시간이 가장 적게 남은 키를 삭제한다.
* 앞선 LRU, LFU 와 같이 근사 알고리즘을 이용하므로, 모든 키를 스캔하면서 만료시간을 비교하지 않아도 되어 간단하게 키를 찾아 낼 수 있다.



### 캐시 스탬피드 현상

> 모든 키에 대해 만료 시간을 설정하는 것은 권장되지만 대규모 트래픽 환경에서 만료시간을 어떻게 설정하느냐에 따라 예상치 못한 문제 상황이 발생할 수 있다.

* 여러 개의 어플리케이션에서 바라보던 동일한 키가 만료되어 삭제된다면 동시에 원본 데이터베이스로 가서 데이터를 읽어오게 되는데, 이 때 중복 읽기가 발생할 수 있다.
* 이 때, 원본 데이터베이스에 무거운 쿼리를 실행하는 중복 읽기가 발생해 부하를 줄 수 있다.
* 이러한 스탬피드 현상이 한번만 발생하더라도 더 많은 현상이 영향을 받게되어 `계단식 실패`로 부른다.

#### 적절한 만료 시간 설정

* 가장 간단한 방법으로는 만료시간은 너무 짧지않게 설정하는 것이다.
* 여러 어플리케이션에서 반복적으로 자주 사용되는 데이터라면 충분히 길게 설정해 주는 것이 좋다.

#### 선 계산

* 스탬피드가 문제되는 이유는 동시다발적으로 어려 어플리케이션에서 인지하여 원본 데이터베이스로 데이터를 읽어오는 것이다.
* 이러한 문제를 키가만료되기 전에 이 값을 미리 갱신해 줌으로 캐시 스탬피드를 줄일 수 있다.
* 이는 더 많은 리소스를 사용한다고 볼 수도 있지만 결과적으로 스탬피드 현상을 줄일 수 있기 때문에 전체적인 성능을 향상시키는 방법일 수도 있다.
* 예를 들어 랜덤한 확률로 데이터베이스에 접근해서 데이터를 읽어와 캐시의 값을 갱신하는 방법이다.
  * 랜덤으로 가져온 키의 만료 시간이 10초 이내라면 미리 새로운 데이터를 가지고와 저장하는 것이다.
  * 이는 만료 시간 기준을 적절히 설정해 주는 것이 중요하다.

#### PER 알고리즘

* 캐시 값이 만료되기 전에 언제 데이터베이스에 접근해서 값을 읽어오면 되는지 최적으로 계산하는 방법이다.
* 이는 아래와 같은 공식을 사용한다.&#x20;
  * `currentTime - (timeToCompute * beta * log(rand))) > expiry`
  * **currentTIme**: 현재 남은 만료 시간
  * **timeToCompute**: 캐시된 값을 다시 계산하는 데 걸리는 시간.
  * **beta**: 기본적으로 1.0 보다 큰값으로 설정.
  * **rand**: 0과 1 사이의 랜덤 값을 반환하는 함수.
  * **expiry**: 키를 재 설정할 때 새로 넣어줄 만료  시간.
* 이 알고리즘은 만료 시간에 가까워질 수록 `true`를 반환할 확률이 높아진다.



## 세션 스토어로서의 레디스

***

### 세션 스토어가 필요한 이유

* 웹 서버가 확장됨에 세션스토어가 서버마다 존재할 경우 사용자는 세션을 발급한 서버와만 통신을 할 수 있어 트래픽을 분산 시킬 수 없는 상황이 발생한다.
* 이를레디스를 세션스토어를 두어 각 사용자는 서버에 구애 받지 않고 동일한 세션을 사용할 수 있다.
  * 이는 관계형 데이터베이스를 통해서도 해결할 수 있을 것 같지만, 세션이 활성화 되어 있는 동안 세션 스토어에도 활발하게 액세스 하기 때문에 전반적인 응답 속도의 저하로 이어질 수 있다.
  * 그에 반해 레디스는 훨씬 빠르고 접근하기도 간편하므로 데이터를 가볍게 저장할 수 있다.

```sql
HMSET userSession:1 Name Minsu Ip 10.10.104:30 Hits 1
```

* 레디스의 hash 자료 구조는 세션 데이터를 저장하기에 알맞는 형태이다.

### 캐시와 세션의 차이

> 캐시와 세션은 비슷해 보이지만 데이터를 읽고 쓰는 패턴에 있어 약간의 차이점을 갖는다.

#### 레디스를 캐시로 사용하는 경우

* 보통 레디스를 캐시로 사용할 때 가장 일반적인 look aside 전략을 사용하는데,
* 캐시는 데이터베이스와 완벽한 서브셋으로 동작한다.
* 이는 캐시 내부의 데이터가 유실되더라도 해당 데이터는 데이터베이스에서 찾을 수 있다.
* 해당 캐시는 여러 어플리케이션에서 함께 사용할 수 있으며, 그것이 더 효율적이다.

#### 레디스를 세션 스토어로 사용하는 경우&#x20;

* 세션 스토어에 저장된 데이터는 여러 사용자 간 공유되지 않으며 특정 사용자에 한해 유효하다.
* 일반적인 세션은 사용자가 로그인 하면 세션 스토어에 저장된다.
* 이후 로그아웃 등으로 사용자가 떠나면 그제야 데이터베이스에 저장한다.
* &#x20;이렇듯 세션 스토어에 장애가 발생하면 내부 데이터가 손실될 가능성이 있으므로 캐시로 사용할 때보다 신중한 운영이 필요하다.















